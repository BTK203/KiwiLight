#include "Runner.h"

/**
 * Source file for the Target class.
 * Written By: Brach Knutson
 */

using namespace cv;
using namespace KiwiLight;

/**
 * Creates a new Target object with the vector of contours. 
 * DO NOT use this to create a new target, Targets will be 
 * generated by the ExampleTarget class. Use an ExampleTarget 
 * to find targets!!!
 */
Target::Target(int id, std::vector<Contour> contours) {
    this->id = id;
    this->contours = contours;

    if(contours.size() == 1) {
        this->width = contours[0].Width();
        this->height = contours[0].Height();
        this->x = (this->width / 2) + contours[0].X();
        this->y = (this->height / 2) + contours[0].Y();
    } else {
        int biggestX = -5000;
        int smallestX = 5000;
        int biggestY = -5000;
        int smallestY = 5000;

        int biggestXWidth = 0;
        int biggestYHeight = 0; 

        for(int i=0; i<contours.size(); i++) {
            if(contours[i].X() > biggestX) {
                biggestX = contours[i].X();
                biggestXWidth = contours[i].Width();
            } 
            else if(contours[i].X() < smallestX) {
                smallestX = contours[i].X();
            }

            if(contours[i].Y() > biggestY) {
                biggestY = contours[i].Y();
                biggestYHeight = contours[i].Height();
            }
            else if(contours[i].Y() < smallestY) {
                smallestY = contours[i].Y();
            }
        }

        this->width = (biggestX - smallestX) + biggestXWidth;
        this->height = (biggestY - smallestY) + biggestYHeight;
        this->x = (this->width / 2) + smallestX;
        this->y = (this->height / 2) + smallestY;

        // std::cout << "width: " << this->width << std::endl;
        // std::cout << "height: " << this->height << std::endl;
        // std::cout << "x: " << this->x << std::endl;
        // std::cout << "y: " << this->y << std::endl;
    }
}

/**
 * Returns a rectangle that represents the bounds of the target.
 */
cv::Rect Target::Bounds() {
    //find the corner x and y because the local x and y are for the center
    int trueX = this->x - (this->width / 2);
    int trueY = this->y - (this->height / 2);

    return cv::Rect(trueX, trueY, this->width, this->height);
}