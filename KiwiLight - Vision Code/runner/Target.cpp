#include "Runner.h"

/**
 * Source file for the Target class.
 * Written By: Brach Knutson
 */

using namespace cv;
using namespace KiwiLight;


Target::Target() {
    this->id = -1;
    this->contours = std::vector<Contour>();
    this->knownHeight = -1;
    this->focalHeight = -1;
    this->distErrorCorrect = -1;
    this->calibratedDistance = -1;
    this->width = -1;
    this->height = -1;
    this->x = -1;
    this->y = -1;
}

/**
 * Creates a new Target object with the vector of contours. 
 * DO NOT use this to find a target, Targets will be 
 * generated by the ExampleTarget class. Use an ExampleTarget 
 * to find targets!!!
 */
Target::Target(int id, std::vector<Contour> contours, double knownHeight, double focalHeight, double distErrorCorrect, double calibratedDistance) {
    this->id = id;
    this->contours = contours;
    this->knownHeight = knownHeight;
    this->focalHeight = focalHeight;
    this->distErrorCorrect = distErrorCorrect;
    this->calibratedDistance = calibratedDistance;

    if(contours.size() == 1) {
        this->width = contours[0].Width();
        this->height = contours[0].Height();
        this->x = (this->width / 2) + contours[0].X();
        this->y = (this->height / 2) + contours[0].Y();
    } else {
        int biggestX = -5000;
        int smallestX = 5000;
        int biggestY = -5000;
        int smallestY = 5000;

        int biggestXWidth = 0;
        int biggestYHeight = 0; 

        for(int i=0; i<contours.size(); i++) {
            if(contours[i].X() > biggestX) {
                biggestX = contours[i].X();
                biggestXWidth = contours[i].Width();
            } 
             if(contours[i].X() < smallestX) {
                smallestX = contours[i].X();
            }

            if(contours[i].Y() > biggestY) {
                biggestY = contours[i].Y();
                biggestYHeight = contours[i].Height();
            }
             if(contours[i].Y() < smallestY) {
                smallestY = contours[i].Y();
            }
        }

        this->width = (biggestX - smallestX) + biggestXWidth;
        this->height = (biggestY - smallestY) + biggestYHeight;
        this->x = (this->width / 2) + smallestX;
        this->y = (this->height / 2) + smallestY;

        // std::cout << "biggest x: " << biggestX << std::endl;
        // std::cout << "biggest x width: " << biggestXWidth << std::endl;
        // std::cout << "smallest x: " << smallestX << std::endl;
        // std::cout << "total width: " << this->width << std::endl;
    }
}

/**
 * Returns the distance from the camera to the target in inches.
 */
double Target::Distance() { 
    //calculate distance (formula: known(in) * focal(in) / real(px))
    double dist = this->knownHeight * this->focalHeight / (double) this->Bounds().width;

    double err = this->calibratedDistance - dist;
    err *= this->distErrorCorrect;
    
    return (dist + err);
}


int Target::HorizontalAngle(double distanceToTarget, int imageCenterX) {
    double inchesPerPixel = this->knownHeight / this->Bounds().width;
    int pixelsToTarget = imageCenterX - this->Center().x;

    double inchesToTarget = pixelsToTarget * inchesPerPixel;
    double angle = atan(inchesToTarget / distanceToTarget);

    //convert to degrees
    angle *= (180 / M_PI);
    return (int) angle;
}


int Target::HorizontalAngle(int imageCenterX) {
    return this->HorizontalAngle(this->Distance(), imageCenterX);
}


int Target::VerticalAngle(double distanceToTarget, int imageCenterY) {
    double InchesPerPixel = this->knownHeight / this->Bounds().width;
    int pixelsToTarget = imageCenterY - this->Center().y;
    
    double inchesToTarget = pixelsToTarget * InchesPerPixel;
    double angle = atan(inchesToTarget / distanceToTarget);

    //convert to degrees and return
    angle *= (180 / M_PI);
    return (int) angle;
}


int Target::VerticalAngle(int imageCenterY) {
    return this->VerticalAngle(this->Distance(), imageCenterY);
}

/**
 * Returns a rectangle that represents the bounds of the target.
 */
cv::Rect Target::Bounds() {
    //find the corner x and y because the local x and y are for the center
    int trueX = this->x - (this->width / 2);
    int trueY = this->y - (this->height / 2);

    return cv::Rect(trueX, trueY, this->width, this->height);
}