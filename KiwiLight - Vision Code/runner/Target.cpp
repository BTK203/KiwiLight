#include "Runner.h"

/**
 * Source file for the Target class.
 * Written By: Brach Knutson
 */

using namespace cv;
using namespace KiwiLight;

/**
 * Creates a new Target object with the vector of contours. 
 * DO NOT use this to create a new target, Targets will be 
 * generated by the ExampleTarget class. Use an ExampleTarget 
 * to find targets!!!
 */
Target::Target(int id, std::vector<Contour> contours, double knownHeight, double focalHeight, double distErrorCorrect, double calibratedDistance) {
    this->id = id;
    this->contours = contours;
    this->knownHeight = knownHeight;
    this->focalHeight = focalHeight;
    this->distErrorCorrect = distErrorCorrect;
    this->calibratedDistance = calibratedDistance;

    if(contours.size() == 1) {
        this->width = contours[0].Width();
        this->height = contours[0].Height();
        this->x = (this->width / 2) + contours[0].X();
        this->y = (this->height / 2) + contours[0].Y();
    } else {
        int biggestX = -5000;
        int smallestX = 5000;
        int biggestY = -5000;
        int smallestY = 5000;

        int biggestXWidth = 0;
        int biggestYHeight = 0; 

        for(int i=0; i<contours.size(); i++) {
            if(contours[i].X() > biggestX) {
                biggestX = contours[i].X();
                biggestXWidth = contours[i].Width();
            } 
            else if(contours[i].X() < smallestX) {
                smallestX = contours[i].X();
            }

            if(contours[i].Y() > biggestY) {
                biggestY = contours[i].Y();
                biggestYHeight = contours[i].Height();
            }
            else if(contours[i].Y() < smallestY) {
                smallestY = contours[i].Y();
            }
        }

        this->width = (biggestX - smallestX) + biggestXWidth;
        this->height = (biggestY - smallestY) + biggestYHeight;
        this->x = (this->width / 2) + smallestX;
        this->y = (this->height / 2) + smallestY;

        // std::cout << "width: " << this->width << std::endl;
        // std::cout << "height: " << this->height << std::endl;
        // std::cout << "x: " << this->x << std::endl;
        // std::cout << "y: " << this->y << std::endl;
    }
}

/**
 * Returns the distance from the camera to the target in inches.
 */
double Target::Distance() { 
    //calculate distance (formula: known(in) / focal(in) * real(px))
    double dist = (this->knownHeight / this->focalHeight) * (double) this->Bounds().width;

    double err = this->calibratedDistance - dist;
    err *= this->distErrorCorrect;

    return (dist + err);
}


int Target::Angle(double distanceToTarget, int imageCenterX) {
    double pixelsToInches = this->knownHeight / this->Bounds().width;
    int pixelsToTarget = imageCenterX - this->Center().x;

    double inchesToTarget = pixelsToTarget * pixelsToInches;
    double angle = atan(inchesToTarget / distanceToTarget);

    //convert to degrees
    angle *= (180 / M_PI);
    return (int) angle;
}


int Target::Angle(int imageCenterX) {
    return this->Angle(this->Distance(), imageCenterX);
}

/**
 * Returns a rectangle that represents the bounds of the target.
 */
cv::Rect Target::Bounds() {
    //find the corner x and y because the local x and y are for the center
    int trueX = this->x - (this->width / 2);
    int trueY = this->y - (this->height / 2);

    return cv::Rect(trueX, trueY, this->width, this->height);
}